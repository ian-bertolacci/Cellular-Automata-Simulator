
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Fri Feb 14 10:30:53 MST 2014
//----------------------------------------------------

package parser;

import java_cup.runtime.*;
import parser.parser_containers.*;
import java.io.FileNotFoundException;
import java.io.FileInputStream;
import java.util.ArrayList;
import java.util.Stack;
import java.util.Iterator;
import java.io.File;
import instruction.*;
import instruction.Break.Condition;
import instruction.Instruction.InstructionType;
import instruction.Operator.Operation;
import machine.VirtualMachine.VarType;
import machine.VirtualMachine;
import machine.*;
import automata.Automata;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Fri Feb 14 10:30:53 MST 2014
  */
public class MataParser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public MataParser() {super();}

  /** Constructor which sets the default scanner. */
  public MataParser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public MataParser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\055\000\002\002\004\000\002\002\004\000\002\014" +
    "\014\000\002\004\003\000\002\010\004\000\002\010\003" +
    "\000\002\007\003\000\002\007\003\000\002\007\007\000" +
    "\002\015\002\000\002\007\014\000\002\011\004\000\002" +
    "\016\002\000\002\011\006\000\002\005\011\000\002\005" +
    "\003\000\002\006\007\000\002\006\011\000\002\003\006" +
    "\000\002\003\005\000\002\003\011\000\002\003\010\000" +
    "\002\003\004\000\002\012\005\000\002\012\005\000\002" +
    "\012\005\000\002\012\005\000\002\012\005\000\002\012" +
    "\005\000\002\012\005\000\002\012\005\000\002\012\005" +
    "\000\002\012\005\000\002\012\005\000\002\012\005\000" +
    "\002\012\005\000\002\012\004\000\002\012\004\000\002" +
    "\012\005\000\002\012\003\000\002\013\003\000\002\013" +
    "\003\000\002\013\003\000\002\013\003\000\002\013\006" +
    "" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\161\000\004\047\005\001\002\000\004\002\163\001" +
    "\002\000\004\032\152\001\002\000\022\004\017\005\016" +
    "\033\024\041\015\043\007\044\ufff8\045\013\046\022\001" +
    "\002\000\004\035\146\001\002\000\024\002\ufffe\004\017" +
    "\005\016\033\024\041\015\043\007\044\ufff8\045\013\046" +
    "\022\001\002\000\004\011\145\001\002\000\026\002\ufffc" +
    "\004\ufffc\005\ufffc\033\ufffc\034\ufffc\041\ufffc\043\ufffc\044" +
    "\ufffc\045\ufffc\046\ufffc\001\002\000\004\012\137\001\002" +
    "\000\004\044\126\001\002\000\004\035\116\001\002\000" +
    "\004\004\113\001\002\000\006\032\105\037\104\001\002" +
    "\000\030\002\ufff2\004\ufff2\005\ufff2\033\ufff2\034\ufff2\041" +
    "\ufff2\042\ufff2\043\ufff2\044\ufff2\045\ufff2\046\ufff2\001\002" +
    "\000\026\002\ufffa\004\ufffa\005\ufffa\033\ufffa\034\ufffa\041" +
    "\ufffa\043\ufffa\044\ufffa\045\ufffa\046\ufffa\001\002\000\020" +
    "\004\036\006\033\007\037\010\034\014\032\031\042\035" +
    "\041\001\002\000\026\002\ufffb\004\ufffb\005\ufffb\033\ufffb" +
    "\034\ufffb\041\ufffb\043\ufffb\044\ufffb\045\ufffb\046\ufffb\001" +
    "\002\000\022\004\ufff5\005\ufff5\033\ufff5\041\ufff5\043\ufff5" +
    "\044\ufff5\045\ufff5\046\ufff5\001\002\000\004\002\001\001" +
    "\002\000\022\004\017\005\016\033\024\041\015\043\007" +
    "\044\ufff8\045\013\046\022\001\002\000\024\004\017\005" +
    "\016\033\024\034\031\041\015\043\007\044\ufff8\045\013" +
    "\046\022\001\002\000\026\002\ufffd\004\ufffd\005\ufffd\033" +
    "\ufffd\034\ufffd\041\ufffd\043\ufffd\044\ufffd\045\ufffd\046\ufffd" +
    "\001\002\000\030\002\ufff4\004\ufff4\005\ufff4\033\ufff4\034" +
    "\ufff4\041\ufff4\042\ufff4\043\ufff4\044\ufff4\045\ufff4\046\ufff4" +
    "\001\002\000\020\004\036\006\033\007\037\010\034\014" +
    "\032\031\042\035\041\001\002\000\042\011\uffd9\013\uffd9" +
    "\014\uffd9\015\uffd9\016\uffd9\017\uffd9\021\uffd9\022\uffd9\023" +
    "\uffd9\024\uffd9\025\uffd9\026\uffd9\027\uffd9\030\uffd9\036\uffd9" +
    "\040\uffd9\001\002\000\042\011\uffd7\013\uffd7\014\uffd7\015" +
    "\uffd7\016\uffd7\017\uffd7\021\uffd7\022\uffd7\023\uffd7\024\uffd7" +
    "\025\uffd7\026\uffd7\027\uffd7\030\uffd7\036\uffd7\040\uffd7\001" +
    "\002\000\040\011\uffeb\013\052\014\044\015\056\016\046" +
    "\017\047\021\055\022\050\023\057\024\054\025\051\026" +
    "\053\027\045\030\060\036\uffeb\001\002\000\044\011\uffd6" +
    "\013\uffd6\014\uffd6\015\uffd6\016\uffd6\017\uffd6\021\uffd6\022" +
    "\uffd6\023\uffd6\024\uffd6\025\uffd6\026\uffd6\027\uffd6\030\uffd6" +
    "\036\uffd6\037\100\040\uffd6\001\002\000\042\011\uffd8\013" +
    "\uffd8\014\uffd8\015\uffd8\016\uffd8\017\uffd8\021\uffd8\022\uffd8" +
    "\023\uffd8\024\uffd8\025\uffd8\026\uffd8\027\uffd8\030\uffd8\036" +
    "\uffd8\040\uffd8\001\002\000\042\011\uffda\013\uffda\014\uffda" +
    "\015\uffda\016\uffda\017\uffda\021\uffda\022\uffda\023\uffda\024" +
    "\uffda\025\uffda\026\uffda\027\uffda\030\uffda\036\uffda\040\uffda" +
    "\001\002\000\020\004\036\006\033\007\037\010\034\014" +
    "\032\031\042\035\041\001\002\000\020\004\036\006\033" +
    "\007\037\010\034\014\032\031\042\035\041\001\002\000" +
    "\042\011\uffdd\013\uffdd\014\uffdd\015\uffdd\016\uffdd\017\uffdd" +
    "\021\uffdd\022\uffdd\023\uffdd\024\uffdd\025\uffdd\026\uffdd\027" +
    "\uffdd\030\uffdd\036\uffdd\040\uffdd\001\002\000\020\004\036" +
    "\006\033\007\037\010\034\014\032\031\042\035\041\001" +
    "\002\000\020\004\036\006\033\007\037\010\034\014\032" +
    "\031\042\035\041\001\002\000\020\004\036\006\033\007" +
    "\037\010\034\014\032\031\042\035\041\001\002\000\020" +
    "\004\036\006\033\007\037\010\034\014\032\031\042\035" +
    "\041\001\002\000\020\004\036\006\033\007\037\010\034" +
    "\014\032\031\042\035\041\001\002\000\020\004\036\006" +
    "\033\007\037\010\034\014\032\031\042\035\041\001\002" +
    "\000\020\004\036\006\033\007\037\010\034\014\032\031" +
    "\042\035\041\001\002\000\020\004\036\006\033\007\037" +
    "\010\034\014\032\031\042\035\041\001\002\000\020\004" +
    "\036\006\033\007\037\010\034\014\032\031\042\035\041" +
    "\001\002\000\020\004\036\006\033\007\037\010\034\014" +
    "\032\031\042\035\041\001\002\000\020\004\036\006\033" +
    "\007\037\010\034\014\032\031\042\035\041\001\002\000" +
    "\020\004\036\006\033\007\037\010\034\014\032\031\042" +
    "\035\041\001\002\000\020\004\036\006\033\007\037\010" +
    "\034\014\032\031\042\035\041\001\002\000\042\011\uffe5" +
    "\013\052\014\044\015\056\016\046\017\047\021\055\022" +
    "\050\023\057\024\054\025\051\026\053\027\uffe5\030\uffe5" +
    "\036\uffe5\040\uffe5\001\002\000\026\011\uffe1\013\052\014" +
    "\044\015\056\016\046\017\047\027\uffe1\030\uffe1\036\uffe1" +
    "\040\uffe1\001\002\000\042\011\uffe8\013\uffe8\014\uffe8\015" +
    "\uffe8\016\uffe8\017\uffe8\021\uffe8\022\uffe8\023\uffe8\024\uffe8" +
    "\025\uffe8\026\uffe8\027\uffe8\030\uffe8\036\uffe8\040\uffe8\001" +
    "\002\000\026\011\uffdf\013\052\014\044\015\056\016\046" +
    "\017\047\027\uffdf\030\uffdf\036\uffdf\040\uffdf\001\002\000" +
    "\026\011\uffe0\013\052\014\044\015\056\016\046\017\047" +
    "\027\uffe0\030\uffe0\036\uffe0\040\uffe0\001\002\000\026\011" +
    "\uffe3\013\052\014\044\015\056\016\046\017\047\027\uffe3" +
    "\030\uffe3\036\uffe3\040\uffe3\001\002\000\042\011\uffea\013" +
    "\uffea\014\uffea\015\056\016\046\017\047\021\uffea\022\uffea" +
    "\023\uffea\024\uffea\025\uffea\026\uffea\027\uffea\030\uffea\036" +
    "\uffea\040\uffea\001\002\000\026\011\uffe2\013\052\014\044" +
    "\015\056\016\046\017\047\027\uffe2\030\uffe2\036\uffe2\040" +
    "\uffe2\001\002\000\026\011\uffde\013\052\014\044\015\056" +
    "\016\046\017\047\027\uffde\030\uffde\036\uffde\040\uffde\001" +
    "\002\000\042\011\uffe4\013\uffe4\014\uffe4\015\uffe4\016\uffe4" +
    "\017\uffe4\021\uffe4\022\uffe4\023\uffe4\024\uffe4\025\uffe4\026" +
    "\uffe4\027\uffe4\030\uffe4\036\uffe4\040\uffe4\001\002\000\042" +
    "\011\uffe7\013\uffe7\014\uffe7\015\uffe7\016\uffe7\017\uffe7\021" +
    "\uffe7\022\uffe7\023\uffe7\024\uffe7\025\uffe7\026\uffe7\027\uffe7" +
    "\030\uffe7\036\uffe7\040\uffe7\001\002\000\042\011\uffe6\013" +
    "\052\014\044\015\056\016\046\017\047\021\055\022\050" +
    "\023\057\024\054\025\051\026\053\027\uffe6\030\uffe6\036" +
    "\uffe6\040\uffe6\001\002\000\042\011\uffe9\013\uffe9\014\uffe9" +
    "\015\056\016\046\017\047\021\uffe9\022\uffe9\023\uffe9\024" +
    "\uffe9\025\uffe9\026\uffe9\027\uffe9\030\uffe9\036\uffe9\040\uffe9" +
    "\001\002\000\036\013\052\014\044\015\056\016\046\017" +
    "\047\021\055\022\050\023\057\024\054\025\051\026\053" +
    "\027\045\030\060\036\077\001\002\000\042\011\uffdb\013" +
    "\uffdb\014\uffdb\015\uffdb\016\uffdb\017\uffdb\021\uffdb\022\uffdb" +
    "\023\uffdb\024\uffdb\025\uffdb\026\uffdb\027\uffdb\030\uffdb\036" +
    "\uffdb\040\uffdb\001\002\000\020\004\036\006\033\007\037" +
    "\010\034\014\032\031\042\035\041\001\002\000\036\013" +
    "\052\014\044\015\056\016\046\017\047\021\055\022\050" +
    "\023\057\024\054\025\051\026\053\027\045\030\060\040" +
    "\102\001\002\000\042\011\uffd5\013\uffd5\014\uffd5\015\uffd5" +
    "\016\uffd5\017\uffd5\021\uffd5\022\uffd5\023\uffd5\024\uffd5\025" +
    "\uffd5\026\uffd5\027\uffd5\030\uffd5\036\uffd5\040\uffd5\001\002" +
    "\000\042\011\uffdc\013\uffdc\014\uffdc\015\uffdc\016\uffdc\017" +
    "\uffdc\021\uffdc\022\uffdc\023\uffdc\024\uffdc\025\uffdc\026\uffdc" +
    "\027\uffdc\030\uffdc\036\uffdc\040\uffdc\001\002\000\020\004" +
    "\036\006\033\007\037\010\034\014\032\031\042\035\041" +
    "\001\002\000\020\004\036\006\033\007\037\010\034\014" +
    "\032\031\042\035\041\001\002\000\040\011\uffee\013\052" +
    "\014\044\015\056\016\046\017\047\021\055\022\050\023" +
    "\057\024\054\025\051\026\053\027\045\030\060\036\uffee" +
    "\001\002\000\036\013\052\014\044\015\056\016\046\017" +
    "\047\021\055\022\050\023\057\024\054\025\051\026\053" +
    "\027\045\030\060\040\110\001\002\000\004\032\111\001" +
    "\002\000\020\004\036\006\033\007\037\010\034\014\032" +
    "\031\042\035\041\001\002\000\040\011\uffec\013\052\014" +
    "\044\015\056\016\046\017\047\021\055\022\050\023\057" +
    "\024\054\025\051\026\053\027\045\030\060\036\uffec\001" +
    "\002\000\004\032\114\001\002\000\020\004\036\006\033" +
    "\007\037\010\034\014\032\031\042\035\041\001\002\000" +
    "\040\011\uffef\013\052\014\044\015\056\016\046\017\047" +
    "\021\055\022\050\023\057\024\054\025\051\026\053\027" +
    "\045\030\060\036\uffef\001\002\000\020\004\036\006\033" +
    "\007\037\010\034\014\032\031\042\035\041\001\002\000" +
    "\036\013\052\014\044\015\056\016\046\017\047\021\055" +
    "\022\050\023\057\024\054\025\051\026\053\027\045\030" +
    "\060\036\120\001\002\000\022\004\017\005\016\033\024" +
    "\041\015\043\007\044\ufff8\045\013\046\022\001\002\000" +
    "\026\002\ufff1\004\ufff1\005\ufff1\033\ufff1\034\ufff1\041\ufff1" +
    "\043\ufff1\044\ufff1\045\ufff1\046\ufff1\001\002\000\030\002" +
    "\ufffb\004\ufffb\005\ufffb\033\ufffb\034\ufffb\041\ufffb\042\123" +
    "\043\ufffb\044\ufffb\045\ufffb\046\ufffb\001\002\000\016\004" +
    "\017\005\016\033\024\041\015\045\013\046\022\001\002" +
    "\000\026\002\ufff0\004\ufff0\005\ufff0\033\ufff0\034\ufff0\041" +
    "\ufff0\043\ufff0\044\ufff0\045\ufff0\046\ufff0\001\002\000\030" +
    "\002\ufff3\004\ufff3\005\ufff3\033\ufff3\034\ufff3\041\ufff3\042" +
    "\ufff3\043\ufff3\044\ufff3\045\ufff3\046\ufff3\001\002\000\004" +
    "\035\127\001\002\000\012\004\017\005\016\045\013\046" +
    "\022\001\002\000\004\011\131\001\002\000\020\004\036" +
    "\006\033\007\037\010\034\014\032\031\042\035\041\001" +
    "\002\000\036\011\133\013\052\014\044\015\056\016\046" +
    "\017\047\021\055\022\050\023\057\024\054\025\051\026" +
    "\053\027\045\030\060\001\002\000\012\004\017\005\016" +
    "\045\013\046\022\001\002\000\004\036\135\001\002\000" +
    "\022\004\017\005\016\033\024\041\015\043\007\044\ufff8" +
    "\045\013\046\022\001\002\000\026\002\ufff7\004\ufff7\005" +
    "\ufff7\033\ufff7\034\ufff7\041\ufff7\043\ufff7\044\ufff7\045\ufff7" +
    "\046\ufff7\001\002\000\004\005\140\001\002\000\004\004" +
    "\141\001\002\000\004\037\142\001\002\000\020\004\036" +
    "\006\033\007\037\010\034\014\032\031\042\035\041\001" +
    "\002\000\036\013\052\014\044\015\056\016\046\017\047" +
    "\021\055\022\050\023\057\024\054\025\051\026\053\027" +
    "\045\030\060\040\144\001\002\000\006\011\uffed\036\uffed" +
    "\001\002\000\030\002\ufff6\004\ufff6\005\ufff6\033\ufff6\034" +
    "\ufff6\041\ufff6\042\ufff6\043\ufff6\044\ufff6\045\ufff6\046\ufff6" +
    "\001\002\000\020\004\036\006\033\007\037\010\034\014" +
    "\032\031\042\035\041\001\002\000\036\013\052\014\044" +
    "\015\056\016\046\017\047\021\055\022\050\023\057\024" +
    "\054\025\051\026\053\027\045\030\060\036\150\001\002" +
    "\000\022\004\017\005\016\033\024\041\015\043\007\044" +
    "\ufff8\045\013\046\022\001\002\000\026\002\ufff9\004\ufff9" +
    "\005\ufff9\033\ufff9\034\ufff9\041\ufff9\043\ufff9\044\ufff9\045" +
    "\ufff9\046\ufff9\001\002\000\004\006\153\001\002\000\004" +
    "\050\154\001\002\000\004\032\155\001\002\000\004\006" +
    "\156\001\002\000\004\051\157\001\002\000\004\032\160" +
    "\001\002\000\004\006\161\001\002\000\004\011\162\001" +
    "\002\000\022\004\uffff\005\uffff\033\uffff\041\uffff\043\uffff" +
    "\044\uffff\045\uffff\046\uffff\001\002\000\004\002\000\001" +
    "\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\161\000\006\002\003\014\005\001\001\000\002\001" +
    "\001\000\002\001\001\000\022\003\010\004\024\005\022" +
    "\006\020\007\011\010\007\011\017\015\013\001\001\000" +
    "\002\001\001\000\016\003\010\005\022\006\020\007\027" +
    "\011\017\015\013\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\006\012\034\013\037\001\001\000\002" +
    "\001\001\000\004\016\025\001\001\000\002\001\001\000" +
    "\020\003\010\005\022\006\020\007\011\010\026\011\017" +
    "\015\013\001\001\000\016\003\010\005\022\006\020\007" +
    "\027\011\017\015\013\001\001\000\002\001\001\000\002" +
    "\001\001\000\006\012\102\013\037\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\012\075\013" +
    "\037\001\001\000\006\012\042\013\037\001\001\000\002" +
    "\001\001\000\006\012\074\013\037\001\001\000\006\012" +
    "\073\013\037\001\001\000\006\012\072\013\037\001\001" +
    "\000\006\012\071\013\037\001\001\000\006\012\070\013" +
    "\037\001\001\000\006\012\067\013\037\001\001\000\006" +
    "\012\066\013\037\001\001\000\006\012\065\013\037\001" +
    "\001\000\006\012\064\013\037\001\001\000\006\012\063" +
    "\013\037\001\001\000\006\012\062\013\037\001\001\000" +
    "\006\012\061\013\037\001\001\000\006\012\060\013\037" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\012" +
    "\100\013\037\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\012\106\013\037\001\001\000" +
    "\006\012\105\013\037\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\012\111\013\037\001" +
    "\001\000\002\001\001\000\002\001\001\000\006\012\114" +
    "\013\037\001\001\000\002\001\001\000\006\012\116\013" +
    "\037\001\001\000\002\001\001\000\016\003\010\005\121" +
    "\006\020\007\120\011\017\015\013\001\001\000\002\001" +
    "\001\000\002\001\001\000\012\003\010\005\124\006\123" +
    "\011\017\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\003\127\001\001\000\002\001\001" +
    "\000\006\012\131\013\037\001\001\000\002\001\001\000" +
    "\004\003\133\001\001\000\002\001\001\000\016\003\010" +
    "\005\022\006\020\007\135\011\017\015\013\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\006\012\142\013\037\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\006\012\146" +
    "\013\037\001\001\000\002\001\001\000\016\003\010\005" +
    "\022\006\020\007\150\011\017\015\013\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$MataParser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$MataParser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$MataParser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 1;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {
 
	
	

    }



	public SymbolStack symStack = new SymbolStack();
	public Stack< Integer > openReg = new Stack< Integer >();
	public CodeList instructionArray;
	public PartialAutomata partialAutomata;
	
	public MataParser( String fileName ) throws FileNotFoundException {
		super( new MataLex( new FileInputStream(fileName ) ));
		for( int i = 0; i < 16; this.openReg.push(i++) );
	}
	
	public CodeList getAssembly(){
		return this.instructionArray;
	}

	


}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$MataParser$actions {

 
	public Expression evaluatePETree( ExpressionNode node ){
		Expression nodeExp = node.getExpression();
		
		if( node.hasChildren() ){ //internal (op) node
			if( node.getRightNode() != null ){ //normal operation (OP R# R$ -> R%
				if( node.getLeftNode().label() >= node.getRightNode().label() ){ //both (L>R) & (L=R) cases; perform L then R
					Expression lExp = evaluatePETree( node.getLeftNode() );
					Expression rExp = evaluatePETree( node.getRightNode());
					Operator nodeOp = (Operator) node.partialInstruction();
					
					nodeExp.append( lExp.getInstructionList() );
					nodeExp.append( rExp.getInstructionList() );
					nodeExp.setResultLocation( this.parser.openReg.pop() );
					
					nodeOp.setSource1( lExp.getResultLocation() );
					nodeOp.setSource2( rExp.getResultLocation() );
					nodeOp.setDestination( nodeExp.getResultLocation() );
					nodeExp.append( nodeOp );
					
					this.parser.openReg.push( lExp.getResultLocation() );
					this.parser.openReg.push( rExp.getResultLocation() );
					
				} else { // (R>L) case; perform R then L
					Expression rExp = evaluatePETree( node.getRightNode());
					Expression lExp = evaluatePETree( node.getLeftNode() );
					Operator nodeOp = (Operator) node.partialInstruction();
					

					nodeExp.append( rExp.getInstructionList() );
					nodeExp.append( lExp.getInstructionList() );
					nodeExp.setResultLocation( this.parser.openReg.pop() );
					
					nodeOp.setSource1( lExp.getResultLocation() );
					nodeOp.setSource2( rExp.getResultLocation() );
					nodeOp.setDestination( nodeExp.getResultLocation() );
					nodeExp.append( nodeOp );
					
					this.parser.openReg.push( rExp.getResultLocation() );
					this.parser.openReg.push( lExp.getResultLocation() );
					
					
				}//end L/R comparison
			} else { //single operand operation (NOT R# -> R$ ) or LdIn # R_Off -> R#
				
				Expression cExp = evaluatePETree( node.getLeftNode() );
				nodeExp.append( cExp.getInstructionList() );
				nodeExp.setResultLocation( this.parser.openReg.pop() );
				
				if( node.partialInstruction().getType() == InstructionType.OPERATOR ){
					Operator nodeOp = (Operator) node.partialInstruction();
					nodeOp.setSource1( cExp.getResultLocation() );
					nodeOp.setDestination( nodeExp.getResultLocation() );
					nodeExp.append( nodeOp );
				} else if( node.partialInstruction().getType() == InstructionType.LOADIN ){
					LoadIn nodeLdIn = (LoadIn) node.partialInstruction();
					nodeLdIn.setOffset( cExp.getResultLocation() );
					nodeLdIn.setDestination( nodeExp.getResultLocation() );
					nodeExp.append( nodeLdIn );
				} else {
					throw new RuntimeException("Unexpected instruction type \""+node.partialInstruction().getClass()+"\"");
				}
				
				this.parser.openReg.push( cExp.getResultLocation() );
	
			
			} //end RightNode? check
			
		} else { //leaf (imm/ld) node
			
			
			if( node.partialInstruction().getType() == InstructionType.LOAD){
				Load nodeOp = (Load) node.partialInstruction();
				nodeOp.setDestination( this.parser.openReg.pop() );
				nodeExp.setResultLocation( nodeOp.getDestination() );
				nodeExp.append(nodeOp);
			} else if( node.partialInstruction().getType() == InstructionType.LDIMM ){
				LoadImmediate nodeOp = (LoadImmediate) node.partialInstruction();
				nodeOp.setDestination( this.parser.openReg.pop() );
				nodeExp.setResultLocation( nodeOp.getDestination() );
				nodeExp.append(nodeOp);
			} else {
				throw new RuntimeException("Unexpected instruction type \""+node.partialInstruction().getType()+"\"");
			}
			
		}//end hasChild()?
		nodeExp.setEvalType(node.evalType());
		return nodeExp;
	}
	

  private final MataParser parser;

  /** Constructor */
  CUP$MataParser$actions(MataParser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$MataParser$do_action(
    int                        CUP$MataParser$act_num,
    java_cup.runtime.lr_parser CUP$MataParser$parser,
    java.util.Stack            CUP$MataParser$stack,
    int                        CUP$MataParser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$MataParser$result;

      /* select the action based on the action number */
      switch (CUP$MataParser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // rvalue ::= ID OBRACE valExpr CBRACE 
            {
              ExpressionNode RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-3)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).right;
		ExpressionNode expr = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).value;
		
			
			if( expr.evalType() != VarType.INT ){
				throw new RuntimeException("Array index expression must be of type INT, not "+expr.evalType());
			} 
			
			Label label = this.parser.symStack.getLabel(id);
			LoadIn instr = new LoadIn(); 
			instr.setSource( label.getPosition() );
			
			ExpressionNode node = new ExpressionNode();
			node.setLeftNode(expr);
			node.makeLabel();
			node.setPartialInstruction( instr );
			node.setEvalType( label.getType() );
			//System.out.println( node.label() );
			RESULT = node;
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("rvalue",9, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-3)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // rvalue ::= ID 
            {
              ExpressionNode RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		
			Label label = this.parser.symStack.getLabel(id);
			Load instr = new Load();
			instr.setSource( label.getPosition() );
			
			ExpressionNode node = new ExpressionNode();
			node.setLabel( 1 );
			node.setPartialInstruction( instr );
			node.setEvalType( label.getType() );
			
			RESULT = node;

		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("rvalue",9, ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // rvalue ::= BOOLE 
            {
              ExpressionNode RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		boolean b = (boolean)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		
			LoadImmediate instr = new LoadImmediate();
			instr.setValue( b );
			
			ExpressionNode node = new ExpressionNode();
			node.setLabel( 1 );
			node.setPartialInstruction( instr );
			node.setEvalType( VarType.BOOLE );
			
			RESULT = node;
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("rvalue",9, ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // rvalue ::= REAL 
            {
              ExpressionNode RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		double r = (double)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		
			LoadImmediate instr = new LoadImmediate();
			instr.setValue( r );
			
			ExpressionNode node = new ExpressionNode();
			node.setLabel( 1 );
			node.setPartialInstruction( instr );
			node.setEvalType( VarType.REAL );
			
			RESULT = node;
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("rvalue",9, ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // rvalue ::= INT 
            {
              ExpressionNode RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		int i = (int)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		
			LoadImmediate instr = new LoadImmediate();
			instr.setValue( i );
			ExpressionNode node = new ExpressionNode();
			node.setLabel( 1 );
			node.setPartialInstruction( instr );
			node.setEvalType( VarType.INT );
			
			RESULT = node;
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("rvalue",9, ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // valExpr ::= rvalue 
            {
              ExpressionNode RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		ExpressionNode a = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		
			RESULT = a;
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("valExpr",8, ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // valExpr ::= OPAREN valExpr CPAREN 
            {
              ExpressionNode RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).right;
		ExpressionNode e = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).value;
		
			RESULT = e;
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("valExpr",8, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // valExpr ::= MINUS valExpr 
            {
              ExpressionNode RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		ExpressionNode a = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		 
			//instruction for psudo left node
			LoadImmediate zeroInstr = new LoadImmediate();
			
			
			if( a.evalType() == VarType.INT ){
				zeroInstr.setValue( new Integer(0) );
			} else if( a.evalType() == VarType.REAL ){
				zeroInstr.setValue( new Double( 0.0 ) );
			} else {
				throw new RuntimeException("The operation \"-\" is not applicable for type "+a.evalType() );
			}
								
			//construct psudo left noded for 0 - a;
			ExpressionNode zeroNode = new ExpressionNode();
			zeroNode.setLabel( 1) ;
			zeroNode.setPartialInstruction( zeroInstr );
			zeroNode.getExpression().setEvalType( a.evalType() );

			//construct this node
			Operator instr = new Operator();
			instr.setOperator( Operation.MINUS );
			
			ExpressionNode node = new ExpressionNode();
			node.setLeftNode( zeroNode );
			node.setRightNode( a );
			node.makeLabel();
			node.setPartialInstruction( instr );
			node.setEvalType( a.evalType() );
			
			RESULT = node;
			
			
			
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("valExpr",8, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // valExpr ::= NOT valExpr 
            {
              ExpressionNode RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		ExpressionNode a = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		 
			
			//type checking
			if( a.evalType() != VarType.BOOLE ){
				throw new RuntimeException("The operation \"!\" is not applicable for type "+a.evalType() );
			}
			
			Operator instr = new Operator();
			instr.setOperator( Operation.NOT );
			
			ExpressionNode node = new ExpressionNode();
			node.setLeftNode(a);
			node.makeLabel();
			node.setPartialInstruction( instr );
			node.setEvalType( VarType.BOOLE );
			//System.out.println( node.label() );
			RESULT = node;
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("valExpr",8, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // valExpr ::= valExpr GE valExpr 
            {
              ExpressionNode RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).right;
		ExpressionNode a = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		ExpressionNode b = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		 
			//type checking
			if( a.evalType() != VarType.INT && a .evalType() != VarType.REAL){
				throw new RuntimeException("The operation \"%\" is not applicable for type "+a.evalType() );
			} else if( b.evalType() != VarType.INT && b.evalType() != VarType.REAL){
				throw new RuntimeException("The operation \"%\" is not applicable for type "+b.evalType() );
			} else if( a.evalType() != b.evalType() ){
				throw new RuntimeException("Incompatible types "+a.evalType() +" and " +b.evalType() );
			}
						
			Operator instr = new Operator();
			instr.setOperator( Operation.LE );
			
			ExpressionNode node = new ExpressionNode();
			node.setLeftNode( b );
			node.setRightNode( a );
			node.makeLabel();
			node.setPartialInstruction( instr );
			node.setEvalType( VarType.BOOLE );
		
			RESULT = node;
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("valExpr",8, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // valExpr ::= valExpr GT valExpr 
            {
              ExpressionNode RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).right;
		ExpressionNode a = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		ExpressionNode b = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		 
			//type checking
			if( a.evalType() != VarType.INT && a .evalType() != VarType.REAL){
				throw new RuntimeException("The operation \"%\" is not applicable for type "+a.evalType() );
			} else if( b.evalType() != VarType.INT && b.evalType() != VarType.REAL){
				throw new RuntimeException("The operation \"%\" is not applicable for type "+b.evalType() );
			} else if( a.evalType() != b.evalType() ){
				throw new RuntimeException("Incompatible types "+a.evalType() +" and " +b.evalType() );
			}
						
			Operator instr = new Operator();
			instr.setOperator( Operation.LT );
			
			ExpressionNode node = new ExpressionNode();
			node.setLeftNode( b );
			node.setRightNode( a );
			node.makeLabel();
			node.setPartialInstruction( instr );
			node.setEvalType( VarType.BOOLE );
			
			RESULT = node;
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("valExpr",8, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // valExpr ::= valExpr LE valExpr 
            {
              ExpressionNode RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).right;
		ExpressionNode a = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		ExpressionNode b = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		 
			//type checking
			if( a.evalType() != VarType.INT && a .evalType() != VarType.REAL){
				throw new RuntimeException("The operation \"%\" is not applicable for type "+a.evalType() );
			} else if( b.evalType() != VarType.INT && b.evalType() != VarType.REAL){
				throw new RuntimeException("The operation \"%\" is not applicable for type "+b.evalType() );
			} else if( a.evalType() != b.evalType() ){
				throw new RuntimeException("Incompatible types "+a.evalType() +" and " +b.evalType() );
			}
						
			Operator instr = new Operator();
			instr.setOperator( Operation.LE );
			
			ExpressionNode node = new ExpressionNode();
			node.setLeftNode( a );
			node.setRightNode( b );
			node.makeLabel();
			node.setPartialInstruction( instr );
			node.setEvalType( VarType.BOOLE );
			
			RESULT = node;
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("valExpr",8, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // valExpr ::= valExpr LT valExpr 
            {
              ExpressionNode RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).right;
		ExpressionNode a = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		ExpressionNode b = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		 
			//type checking
			if( a.evalType() != VarType.INT && a .evalType() != VarType.REAL){
				throw new RuntimeException("The operation \"%\" is not applicable for type "+a.evalType() );
			} else if( b.evalType() != VarType.INT && b.evalType() != VarType.REAL){
				throw new RuntimeException("The operation \"%\" is not applicable for type "+b.evalType() );
			} else if( a.evalType() != b.evalType() ){
				throw new RuntimeException("Incompatible types "+a.evalType() +" and " +b.evalType() );
			}
						
			Operator instr = new Operator();
			instr.setOperator( Operation.LT );
			
			ExpressionNode node = new ExpressionNode();
			node.setLeftNode( a );
			node.setRightNode( b );
			node.makeLabel();
			node.setPartialInstruction( instr );
			node.setEvalType( VarType.BOOLE );
			
			RESULT = node;
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("valExpr",8, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // valExpr ::= valExpr NEQ valExpr 
            {
              ExpressionNode RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).right;
		ExpressionNode a = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		ExpressionNode b = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		
			//type checking
			//types only have to be the same
			if( a.evalType() != b.evalType() ){
				throw new RuntimeException("Incompatible types "+a.evalType() +" and " +b.evalType() );
			}
						
			Operator instr = new Operator();
			instr.setOperator( Operation.NEQ );
			
			ExpressionNode node = new ExpressionNode();
			node.setLeftNode( a );
			node.setRightNode( b );
			node.makeLabel();
			node.setPartialInstruction( instr );
			node.setEvalType( VarType.BOOLE );
			
			RESULT = node;
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("valExpr",8, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // valExpr ::= valExpr EQ valExpr 
            {
              ExpressionNode RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).right;
		ExpressionNode a = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		ExpressionNode b = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		 
			//type checking
			//types only have to be the same
			if( a.evalType() != b.evalType() ){
				throw new RuntimeException("Incompatible types "+a.evalType() +" and " +b.evalType() );
			}
						
			Operator instr = new Operator();
			instr.setOperator( Operation.EQ );
			
			ExpressionNode node = new ExpressionNode();
			node.setLeftNode( a );
			node.setRightNode( b );
			node.makeLabel();
			node.setPartialInstruction( instr );
			node.setEvalType( VarType.BOOLE );
			
			RESULT = node;
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("valExpr",8, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // valExpr ::= valExpr MOD valExpr 
            {
              ExpressionNode RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).right;
		ExpressionNode a = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		ExpressionNode b = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		 
			//type checking
			if( a.evalType() != VarType.INT && a .evalType() != VarType.REAL){
				throw new RuntimeException("The operation \"%\" is not applicable for type "+a.evalType() );
			} else if( b.evalType() != VarType.INT && b.evalType() != VarType.REAL){
				throw new RuntimeException("The operation \"%\" is not applicable for type "+b.evalType() );
			} else if( a.evalType() != b.evalType() ){
				throw new RuntimeException("Incompatible types "+a.evalType() +" and " +b.evalType() );
			}
						
			Operator instr = new Operator();
			instr.setOperator( Operation.MOD );
			
			ExpressionNode node = new ExpressionNode();
			node.setLeftNode( a );
			node.setRightNode( b );
			node.makeLabel();
			node.setPartialInstruction( instr );
			node.setEvalType( a.evalType() );
			
			RESULT = node;
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("valExpr",8, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // valExpr ::= valExpr OR valExpr 
            {
              ExpressionNode RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).right;
		ExpressionNode a = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		ExpressionNode b = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		 
			//type checking
			if( a.evalType() != VarType.BOOLE){
				throw new RuntimeException("The operation \"|\" is not applicable for type "+a.evalType() );
			} else if( b.evalType() != VarType.BOOLE){
				throw new RuntimeException("The operation \"|\" is not applicable for type "+b.evalType() );
			} 
						
			Operator instr = new Operator();
			instr.setOperator( Operation.OR );
			
			ExpressionNode node = new ExpressionNode();
			node.setLeftNode( a );
			node.setRightNode( b );
			node.makeLabel();
			node.setPartialInstruction( instr );
			node.setEvalType( VarType.BOOLE );
			
			RESULT = node;
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("valExpr",8, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // valExpr ::= valExpr AND valExpr 
            {
              ExpressionNode RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).right;
		ExpressionNode a = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		ExpressionNode b = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		 
			//type checking
			if( a.evalType() != VarType.BOOLE){
				throw new RuntimeException("The operation \"&\" is not applicable for type "+a.evalType() );
			} else if( b.evalType() != VarType.BOOLE){
				throw new RuntimeException("The operation \"&\" is not applicable for type "+b.evalType() );
			} 
						
			Operator instr = new Operator();
			instr.setOperator( Operation.AND );
			
			ExpressionNode node = new ExpressionNode();
			node.setLeftNode( a );
			node.setRightNode( b );
			node.makeLabel();
			node.setPartialInstruction( instr );
			node.setEvalType( VarType.BOOLE );
			
			RESULT = node;
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("valExpr",8, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // valExpr ::= valExpr DIVIDE valExpr 
            {
              ExpressionNode RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).right;
		ExpressionNode a = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		ExpressionNode b = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		 
			//type checking
			if( a.evalType() != VarType.INT && a .evalType() != VarType.REAL){
				throw new RuntimeException("The operation \"/\" is not applicable for type "+a.evalType() );
			} else if( b.evalType() != VarType.INT && b.evalType() != VarType.REAL){
				throw new RuntimeException("The operation \"/\" is not applicable for type "+b.evalType() );
			} else if( a.evalType() != b.evalType() ){
				throw new RuntimeException("Incompatible types "+a.evalType() +" and " +b.evalType() );
			}
						
			Operator instr = new Operator();
			instr.setOperator( Operation.DIVIDE );
			
			ExpressionNode node = new ExpressionNode();
			node.setLeftNode( a );
			node.setRightNode( b );
			node.makeLabel();
			node.setPartialInstruction( instr );
			node.setEvalType( a.evalType() );
			
			RESULT = node;
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("valExpr",8, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // valExpr ::= valExpr TIMES valExpr 
            {
              ExpressionNode RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).right;
		ExpressionNode a = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		ExpressionNode b = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		 
			//type checking
			if( a.evalType() != VarType.INT && a .evalType() != VarType.REAL){
				throw new RuntimeException("The operation \"*\" is not applicable for type "+a.evalType() );
			} else if( b.evalType() != VarType.INT && b.evalType() != VarType.REAL){
				throw new RuntimeException("The operation \"*\" is not applicable for type "+b.evalType() );
			} else if( a.evalType() != b.evalType() ){
				throw new RuntimeException("Incompatible types "+a.evalType() +" and " +b.evalType() );
			}
						
			Operator instr = new Operator();
			instr.setOperator( Operation.TIMES );
			
			ExpressionNode node = new ExpressionNode();
			node.setLeftNode( a );
			node.setRightNode( b );
			node.makeLabel();
			node.setPartialInstruction( instr );
			node.setEvalType( a.evalType() );
			
			RESULT = node;
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("valExpr",8, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // valExpr ::= valExpr MINUS valExpr 
            {
              ExpressionNode RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).right;
		ExpressionNode a = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		ExpressionNode b = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		 
			//type checking
			if( a.evalType() != VarType.INT && a .evalType() != VarType.REAL){
				throw new RuntimeException("The operation \"-\" is not applicable for type "+a.evalType() );
			} else if( b.evalType() != VarType.INT && b.evalType() != VarType.REAL){
				throw new RuntimeException("The operation \"-\" is not applicable for type "+b.evalType() );
			} else if( a.evalType() != b.evalType() ){
				throw new RuntimeException("Incompatible types "+a.evalType() +" and " +b.evalType() );
			}
						
			Operator instr = new Operator();
			instr.setOperator( Operation.MINUS );
			
			ExpressionNode node = new ExpressionNode();
			node.setLeftNode( a );
			node.setRightNode( b );
			node.makeLabel();
			node.setPartialInstruction( instr );
			node.setEvalType( a.evalType() );
			
			RESULT = node;
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("valExpr",8, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // valExpr ::= valExpr PLUS valExpr 
            {
              ExpressionNode RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).right;
		ExpressionNode a = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		ExpressionNode b = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		 
			//type checking
			if( a.evalType() != VarType.INT && a .evalType() != VarType.REAL){
				throw new RuntimeException("The operation \"+\" is not applicable for type "+a.evalType() );
			} else if( b.evalType() != VarType.INT && b.evalType() != VarType.REAL){
				throw new RuntimeException("The operation \"+\" is not applicable for type "+b.evalType() );
			} else if( a.evalType() != b.evalType() ){
				throw new RuntimeException("Incompatible types "+a.evalType() +" and " +b.evalType() );
			}
						
			Operator instr = new Operator();
			instr.setOperator( Operation.PLUS );
			
			ExpressionNode node = new ExpressionNode();
			node.setLeftNode( a );
			node.setRightNode( b );
			node.makeLabel();
			node.setPartialInstruction( instr );
			node.setEvalType( a.evalType() );
			
			RESULT = node;
			
			
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("valExpr",8, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // lineStmt ::= RETURN valExpr 
            {
              CodeList RESULT =null;
		int retExprleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int retExprright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		ExpressionNode retExpr = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		
			Expression rExpr = evaluatePETree(retExpr);
			HaltReturn retInstr = new HaltReturn( rExpr.getResultLocation() );
			rExpr.append(retInstr);
			this.parser.openReg.push( rExpr.getResultLocation() );
			RESULT = new CodeList(rExpr);
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("lineStmt",1, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // lineStmt ::= ID OBRACE valExpr CBRACE ASSIGN valExpr 
            {
              CodeList RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-5)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-5)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-5)).value;
		int indexExprleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-3)).left;
		int indexExprright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-3)).right;
		ExpressionNode indexExpr = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		ExpressionNode e = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		
			//System.out.println("Array assignment");
			
			Label assignInto = this.parser.symStack.getLabel(id);
			//I dont believe there is an optimization problem here
			//given that one expression MUST be held and will no be released
			//until the creation of the store instruction
			Expression vExpr = evaluatePETree( e );
			Expression iExpr = evaluatePETree( indexExpr );
			
			if( iExpr.evalType() != VarType.INT ){
				throw new RuntimeException("Allocation size expression must be of type INT, not "+ iExpr.evalType());
			} else if( assignInto.getType() != vExpr.evalType() ){
				throw new RuntimeException("Attemtpting to assign " + vExpr.evalType() +" type value into a " + assignInto.getType() + " type variable");
			}
			
			int position = assignInto.getPosition();
			int resultLocation = vExpr.getResultLocation();
			int offsetReg = iExpr.getResultLocation();
			StoreIn stInstr = new StoreIn(resultLocation, position, offsetReg);
			this.parser.openReg.push( resultLocation );
			this.parser.openReg.push( offsetReg );
			vExpr.append(iExpr.getInstructionList());
			vExpr.append(stInstr);
			vExpr.nullResultLocation();
			//System.out.println("Assignment: " +id+":\n"+expr+"\n"); 
			RESULT = new CodeList(vExpr);
		
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("lineStmt",1, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-5)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // lineStmt ::= ARRAY COLON TYPE ID OBRACE valExpr CBRACE 
            {
              CodeList RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-4)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-4)).right;
		VarType t = (VarType)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-4)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-3)).value;
		int sizeExprleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).left;
		int sizeExprright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).right;
		ExpressionNode sizeExpr = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).value;
		
			
			Expression expr = evaluatePETree( sizeExpr );
			if( expr.evalType() != VarType.INT ){
				throw new RuntimeException("Allocation size expression must be of type INT, not "+expr.evalType());
			}
			int position = this.parser.symStack.push(id, t);
			int resultLocation = expr.getResultLocation();
			//Store stInstr = new Store(resultLocation, position);
			AllocateArray aaInstr = new AllocateArray( position, resultLocation );
			this.parser.openReg.push( resultLocation );
			expr.append(aaInstr);
			expr.nullResultLocation();
			
			//System.out.println("Array Creation @ " + position);
			RESULT = new CodeList(expr);
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("lineStmt",1, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-6)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // lineStmt ::= ID ASSIGN valExpr 
            {
              CodeList RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		ExpressionNode e = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		
			Expression expr = evaluatePETree( e );
			Label assignInto = this.parser.symStack.getLabel(id);
			if( assignInto.getType() != expr.evalType() ){
				throw new RuntimeException("Attemtpting to assign " + expr.evalType() +" type value into a " + assignInto.getType() + " type variable");
			}
			int position = assignInto.getPosition();
			int resultLocation = expr.getResultLocation();
			Store stInstr = new Store(resultLocation, position);
			this.parser.openReg.push( resultLocation );
			expr.append(stInstr);
			expr.nullResultLocation();
			//System.out.println("Assignment: " +id+":\n"+expr+"\n"); 
			RESULT = new CodeList(expr);

			
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("lineStmt",1, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // lineStmt ::= TYPE ID ASSIGN valExpr 
            {
              CodeList RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-3)).right;
		VarType t = (VarType)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-3)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		ExpressionNode e = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		
			Expression expr = evaluatePETree( e );
			if( t != expr.evalType() ){
				throw new RuntimeException("Attemtpting to assign " + expr.evalType() +" type value into a " + t + " type variable");
			}
			int position = this.parser.symStack.push(id, t);
			int resultLocation = expr.getResultLocation();
			Store stInstr = new Store(resultLocation, position);
			this.parser.openReg.push( resultLocation );
			expr.append(stInstr);
			expr.nullResultLocation();
			//System.out.println("Assignment: " +id+":\n"+expr+"\n"); 
			RESULT = new CodeList(expr);
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("lineStmt",1, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-3)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // openStmt ::= IF OPAREN valExpr CPAREN closedStmt ELSE openStmt 
            {
              CodeList RESULT =null;
		int condNodeleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-4)).left;
		int condNoderight = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-4)).right;
		ExpressionNode condNode = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-4)).value;
		int ifTrueleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).left;
		int ifTrueright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).right;
		CodeList ifTrue = (CodeList)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).value;
		int ifFalseleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int ifFalseright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		CodeList ifFalse = (CodeList)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		
				//System.out.println("openStmt:IF,ELSE-IF");
				
				CodeList list = new CodeList();
				Expression condExpr = evaluatePETree( condNode );
				Break condBrInstr = new Break(Condition.FALSE, condExpr.getResultLocation(), ifTrue.size()+1 );
				Break endBrInstr = new Break(Condition.UNCONDITIONAL, -1, ifFalse.size() );
				
				if( condExpr.evalType() != VarType.BOOLE ){
					throw new RuntimeException("Conditional expression must evaluate to type BOOLE not " + condExpr.evalType() );
				}
				
				this.parser.openReg.push( condExpr.getResultLocation() );
				
				list.append( condExpr );		//append code for conditional expression
				list.append( condBrInstr );	//append code for conditional expression
				list.append( ifTrue);		//append code for ifTrue statement
				list.append( endBrInstr );	//append unconditional break out of if-else block
				list.append( ifFalse );		//append lower block code
				
				RESULT = new CodeList(list);
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("openStmt",4, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-6)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // openStmt ::= IF OPAREN valExpr CPAREN stmt 
            {
              CodeList RESULT =null;
		int condNodeleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).left;
		int condNoderight = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).right;
		ExpressionNode condNode = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).value;
		int cmpdStmtleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int cmpdStmtright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		CodeList cmpdStmt = (CodeList)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		
			//System.out.println("openStmt:IF");
			
			CodeList list = new CodeList();
			Expression condExpr = evaluatePETree( condNode );
			Break condBrInstr = new Break(Condition.FALSE, condExpr.getResultLocation(), cmpdStmt.size() ); //if(false) skip
			
			if( condExpr.evalType() != VarType.BOOLE ){
					throw new RuntimeException("Conditional expression must evaluate to type BOOLE not " + condExpr.evalType() );
			}
			
			this.parser.openReg.push( condExpr.getResultLocation() );
			
			list.append( condExpr );		//append code for conditional expression
			list.append( condBrInstr );	//append code for conditional expression
			list.append( cmpdStmt );	//append code for ifTrue statement
			//there is no br_u because the code it would jump to is what it would already execute next
			
			RESULT = new CodeList(list);
		
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("openStmt",4, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-4)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // closedStmt ::= lowerStmts 
            {
              CodeList RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		CodeList s = (CodeList)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		
			//System.out.println("closedStmt:lowerStmts");
			RESULT = s;
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("closedStmt",3, ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // closedStmt ::= IF OPAREN valExpr CPAREN closedStmt ELSE closedStmt 
            {
              CodeList RESULT =null;
		int condNodeleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-4)).left;
		int condNoderight = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-4)).right;
		ExpressionNode condNode = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-4)).value;
		int ifTrueleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).left;
		int ifTrueright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).right;
		CodeList ifTrue = (CodeList)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).value;
		int ifFalseleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int ifFalseright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		CodeList ifFalse = (CodeList)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		
			//System.out.println("closedStmt:IF-ELSE");
			
			CodeList list = new CodeList();
			Expression condExpr = evaluatePETree( condNode );
			Break condBrInstr = new Break(Condition.FALSE, condExpr.getResultLocation(), ifTrue.size()+1 );
			Break endBrInstr = new Break(Condition.UNCONDITIONAL, -1, ifFalse.size() );
			
			if( condExpr.evalType() != VarType.BOOLE ){
				throw new RuntimeException("Conditional expression must evaluate to type BOOLE not " + condExpr.evalType() );
			}
			
			this.parser.openReg.push( condExpr.getResultLocation() );
			
			list.append( condExpr );		//append code for conditional expression
			list.append( condBrInstr );	//append code for conditional expression
			list.append( ifTrue);		//append code for ifTrue statement
			list.append( endBrInstr );	//append unconditional break out of if-else block
			list.append( ifFalse );		//append lower block code
			
			RESULT = list;

		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("closedStmt",3, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-6)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // lowerStmts ::= OBRAK NT$1 stmts CBRAK 
            {
              CodeList RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (CodeList) ((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).right;
		CodeList s = (CodeList)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).value;
		
		//System.out.println( "Before: " + this.parser.symStack.toString() );
		this.parser.symStack.pop();
		//System.out.println( "After: " + this.parser.symStack.toString() );
		RESULT = s;
	
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("lowerStmts",7, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-3)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // NT$1 ::= 
            {
              CodeList RESULT =null;
 this.parser.symStack.newScope(); 
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("NT$1",12, ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // lowerStmts ::= lineStmt SEMICOLON 
            {
              CodeList RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).right;
		CodeList s = (CodeList)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).value;
		
		RESULT = s;
	
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("lowerStmts",7, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // stmt ::= NT$0 FOR OPAREN lineStmt SEMICOLON valExpr SEMICOLON lineStmt CPAREN stmt 
            {
              CodeList RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (CodeList) ((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-9)).value;
		int L1left = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-6)).left;
		int L1right = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-6)).right;
		CodeList L1 = (CodeList)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-6)).value;
		int condNodeleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-4)).left;
		int condNoderight = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-4)).right;
		ExpressionNode condNode = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-4)).value;
		int L2left = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).left;
		int L2right = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).right;
		CodeList L2 = (CodeList)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		CodeList s = (CodeList)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		
	 		//System.out.println("For statement");
	 		CodeList list = new CodeList();
	 		Expression condExpr = evaluatePETree( condNode );
	 		Break condBrInstr = new Break( Condition.FALSE, condExpr.getResultLocation(), s.size()+L2.size()+1);
	 		Break loopBrInstr = new Break( Condition.UNCONDITIONAL, -1, -(s.size() + condExpr.size() + L2.size() + 2));
	 		
	 		if( condExpr.evalType() != VarType.BOOLE ){
				throw new RuntimeException("Conditional expression must evaluate to type BOOLE not " + condExpr.evalType() );
			}
			//this.parser.openReg.push( condExpr.getResultLocation() );
			this.parser.openReg.push( condExpr.getResultLocation() );
			
			list.append(L1);
			list.append(condExpr);
			list.append(condBrInstr);
			list.append(s);
			list.append(L2);
			list.append(loopBrInstr);
	 		
	 		this.parser.symStack.pop();
	 		RESULT = list;
	 	
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("stmt",5, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-9)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // NT$0 ::= 
            {
              CodeList RESULT =null;
 this.parser.symStack.newScope(); 
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("NT$0",11, ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // stmt ::= WHILE OPAREN valExpr CPAREN stmt 
            {
              CodeList RESULT =null;
		int condNodeleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).left;
		int condNoderight = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).right;
		ExpressionNode condNode = (ExpressionNode)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		CodeList s = (CodeList)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		
	 		//System.out.println("While Statement");
	 		CodeList list = new CodeList();
	 		Expression condExpr = evaluatePETree(condNode);
	 		Break condBrInstr = new Break(Condition.FALSE, condExpr.getResultLocation(), s.size()+1);
	 		Break loopBrInstr = new Break(Condition.UNCONDITIONAL, -1, -(s.size() + condExpr.size() + 2));
			
			if( condExpr.evalType() != VarType.BOOLE ){
				throw new RuntimeException("Conditional expression must evaluate to type BOOLE not " + condExpr.evalType() );
			}
			this.parser.openReg.push( condExpr.getResultLocation() );
			
			list.append( condExpr );
			list.append( condBrInstr );
			list.append( s );
			list.append( loopBrInstr );
			
	 		RESULT = list;
	 	
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("stmt",5, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-4)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // stmt ::= openStmt 
            {
              CodeList RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		CodeList e = (CodeList)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		
		//System.out.println("stmt:closedStmt");
			RESULT = e;
	 	
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("stmt",5, ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // stmt ::= closedStmt 
            {
              CodeList RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		CodeList e = (CodeList)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		 
		//System.out.println("stmt:closedStmt");
			RESULT = e;
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("stmt",5, ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // stmts ::= stmt 
            {
              CodeList RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		CodeList e = (CodeList)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		
			
				RESULT = e; 
			
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("stmts",6, ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // stmts ::= stmts stmt 
            {
              CodeList RESULT =null;
		int esleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).left;
		int esright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).right;
		CodeList es = (CodeList)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		CodeList e = (CodeList)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		
				es.append( e.getInstructionList() );
				RESULT = es;
			
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("stmts",6, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // machineDef ::= stmts 
            {
              CodeList RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		CodeList e = (CodeList)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		
				RESULT = e;
			
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("machineDef",2, ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // spaceDef ::= DEFSTATES ASSIGN INT DEFDIMENSION ASSIGN INT DEFRADIUS ASSIGN INT SEMICOLON 
            {
              PartialAutomata RESULT =null;
		int statesleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-7)).left;
		int statesright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-7)).right;
		int states = (int)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-7)).value;
		int dimensionleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-4)).left;
		int dimensionright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-4)).right;
		int dimension = (int)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-4)).value;
		int radiusleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).left;
		int radiusright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).right;
		int radius = (int)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).value;
		
		 	if( states <= 0 ) {
		 		throw new RuntimeException("Error in spatial specification, states cannot be <= 0");
		 	} else if(dimension <= 0 ){
		 		throw new RuntimeException("Error in spatial specification, dimension cannot be <= 0");
		 	} else if( radius < 0 ){
		 		throw new RuntimeException("Error in spatial specification, radius cannot be < 0");
		 	}
		 	
		 	PartialAutomata partialAutomata = new PartialAutomata();
		 	partialAutomata = new PartialAutomata();
		 	partialAutomata.setStates( states );
		 	partialAutomata.setDimensions( dimension );
		 	partialAutomata.setRadius( radius );
		 	parser.symStack.push("neighborhood", VarType.INT);
		 	RESULT = partialAutomata;
		 
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("spaceDef",10, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-9)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).right;
		CodeList start_val = (CodeList)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).value;
		RESULT = start_val;
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$MataParser$parser.done_parsing();
          return CUP$MataParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // program ::= spaceDef machineDef 
            {
              CodeList RESULT =null;
		int valsleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).left;
		int valsright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).right;
		PartialAutomata vals = (PartialAutomata)((java_cup.runtime.Symbol) CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()).right;
		CodeList m = (CodeList)((java_cup.runtime.Symbol) CUP$MataParser$stack.peek()).value;
		
			if( m.get(m.size()-1).getType() != InstructionType.HALTRET ) m.append( new HaltReturn(0));
			/*
			System.out.println( this.parser.openReg.toString() );
			System.out.println( this.parser.symStack.toString() );
			
			Iterator<Instruction> iter = m.getInstructionList().iterator();
			while(iter.hasNext()){
				System.out.println(iter.next().toString());
			}*/
			
			vals.setAssembly( m );
			
			this.parser.partialAutomata = vals;
			
		
              CUP$MataParser$result = parser.getSymbolFactory().newSymbol("program",0, ((java_cup.runtime.Symbol)CUP$MataParser$stack.elementAt(CUP$MataParser$top-1)), ((java_cup.runtime.Symbol)CUP$MataParser$stack.peek()), RESULT);
            }
          return CUP$MataParser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

